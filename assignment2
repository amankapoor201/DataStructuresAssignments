//q1

#include <stdio.h>


int binarySearch(int arr[], int size, int element) {
    int low = 0;
    int high = size - 1;
    int mid;

    while (low <= high) {
        mid = low + (high - low) / 2; 

       
        if (arr[mid] == element) {
            return mid;
        }

      
        if (arr[mid] < element) {
            low = mid + 1;
        }
        
        else {
            high = mid - 1;
        }
    }

    return -1; 
}

int main() {
    
    int arr[] = {11, 12, 22, 25, 34, 64, 90};
    int n = sizeof(arr) / sizeof(arr[0]);
    int searchElement;
    int result;

    printf("Sorted Array: ");
    for (int i = 0; i < n; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");

    printf("Enter the element to search: ");
    scanf("%d", &searchElement);

    result = binarySearch(arr, n, searchElement);

    if (result != -1) {
        printf("Element %d found at index %d.\n", searchElement, result);
    } else {
        printf("Element %d not found in the array.\n", searchElement);
    }

    // Test with an element not in the array
    searchElement = 50;
    result = binarySearch(arr, n, searchElement);
    if (result != -1) {
        printf("Element %d found at index %d.\n", searchElement, result);
    } else {
        printf("Element %d not found in the array.\n", searchElement);
    }

    return 0;
}


//q2

#include <stdio.h>

void bubbleSort(int arr[], int size) {
    int i, j, temp;
    int swapped; 
    for (i = 0; i < size - 1; i++) {
        swapped = 0; 
        for (j = 0; j < size - i - 1; j++) {
        
            if (arr[j] > arr[j + 1]) {
                
                temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
                swapped = 1; 
            }
        }
        
        if (swapped == 0) {
            break;
        }
    }
}

int main() {
    int arr[] = {64, 34, 25, 12, 22, 11, 90};
    int n = sizeof(arr) / sizeof(arr[0]);

    printf("Original Array: ");
    for (int i = 0; i < n; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");

    bubbleSort(arr, n);

    printf("Sorted Array (Bubble Sort): ");
    for (int i = 0; i < n; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");

    return 0;
}

//q3

#include <stdio.h>


int findMissingNumber(int arr[], int size) {
    
    int N = size + 1;
    long long expectedSum = (long long)N * (N + 1) / 2; 

    long long actualSum = 0;
    for (int i = 0; i < size; i++) {
        actualSum += arr[i];
    }

    return (int)(expectedSum - actualSum);
}

int main() {
    
    int arr1[] = {1, 2, 4, 5};
    int n1 = sizeof(arr1) / sizeof(arr1[0]);
    printf("Array 1: ");
    for(int i = 0; i < n1; i++) printf("%d ", arr1[i]);
    printf("\nMissing number in Array 1: %d\n\n", findMissingNumber(arr1, n1));

//q4

#include <stdio.h>
#include <string.h> 
#include <ctype.h>  


void concatenateStrings(char dest[], const char src[]) {
    int i = 0;
    int j = 0;
    
    while (dest[i] != '\0') {
        i++;
    }
    
    while (src[j] != '\0') {
        dest[i] = src[j];
        i++;
        j++;
    }
    dest[i] = '\0'; 
}

void reverseString(char *str) {
    int length = strlen(str);
    int i, j;
    char temp;
    for (i = 0, j = length - 1; i < j; i++, j--) {
        temp = str[i];
        str[i] = str[j];
        str[j] = temp;
    }
}


int isVowel(char c) {
    c = tolower(c); 
    return (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u');
}


void deleteVowels(char *str) {
    int i, j;
    j = 0; 

    for (i = 0; str[i] != '\0'; i++) {
        
        if (!isVowel(str[i])) {
            str[j] = str[i];
            j++;
        }
    }
    str[j] = '\0'; 
}


void sortStringsAlphabetically(char strings[][100], int num_strings) {
    char temp[100]; 
    int i, j;
    for (i = 0; i < num_strings - 1; i++) {
        for (j = 0; j < num_strings - i - 1; j++) {
            
            if (strcmp(strings[j], strings[j + 1]) > 0) {
                strcpy(temp, strings[j]);
                strcpy(strings[j], strings[j + 1]);
                strcpy(strings[j + 1], temp);
            }
        }
    }
}

char charToLowerCase(char c) {
    return tolower(c);
}

int main() {
    
    printf("--- String Concatenation ---\n");
    char s1[100] = "Hello, ";
    char s2[] = "Universe!";
    printf("Original s1: \"%s\"\n", s1);
    printf("String to add s2: \"%s\"\n", s2);
    concatenateStrings(s1, s2);
    printf("Concatenated String: \"%s\"\n\n", s1);

    printf("--- String Reversal ---\n");
    char s3[] = "Programming"; 
    printf("Original String: \"%s\"\n", s3);
    reverseString(s3);
    printf("Reversed String: \"%s\"\n\n", s3);


    printf("--- Delete Vowels ---\n");
    char s4[] = "Beautiful World";
    printf("Original String: \"%s\"\n", s4);
    deleteVowels(s4);
    printf("String after deleting vowels: \"%s\"\n\n", s4);

    
    printf("--- Sort Strings Alphabetically ---\n");
    char stringList[5][100] = {
        "kiwi",
        "apple",
        "orange",
        "grape",
        "banana"
    };
    int num_str = 5;

    printf("Original String List:\n");
    for (int i = 0; i < num_str; i++) {
        printf("- %s\n", stringList[i]);
    }
    sortStringsAlphabetically(stringList, num_str);
    printf("Sorted String List:\n");
    for (int i = 0; i < num_str; i++) {
        printf("- %s\n", stringList[i]);
    }
    printf("\n");

    
    printf("--- Uppercase to Lowercase Character ---\n");
    char ch1 = 'D';
    char ch2 = 'x';
    char ch3 = '7';
    printf("Original character '%c', Lowercase: '%c'\n", ch1, charToLowerCase(ch1));
    printf("Original character '%c', Lowercase: '%c'\n", ch2, charToLowerCase(ch2));
    printf("Original character '%c', Lowercase: '%c'\n", ch3, charToLowerCase(ch3));
    printf("\n");

    return 0;
}


//q5

#include <stdio.h>
#include <stdlib.h>

#define N 5 


void demonstrateDiagonalMatrix() {
    printf("--- (a) Diagonal Matrix (N=%d) ---\n", N);
    
    int diag_elements[N] = {10, 20, 30, 40, 50};

    printf("1D Array storage: ");
    for(int i = 0; i < N; i++) printf("%d ", diag_elements[i]);
    printf("\n\nConceptual Matrix:\n");
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            if (i == j) {
                printf("%d ", diag_elements[i]); 
            } else {
                printf("0 ");
            }
        }
        printf("\n");
    }

    printf("\nAccessing A[2][2]: %d (from diag_elements[2])\n", diag_elements[2]);
    printf("Accessing A[1][3]: 0 (off-diagonal)\n");
   
}


void demonstrateTridiagonalMatrix() {
    printf("--- (b) Tri-diagonal Matrix (N=%d) ---\n", N);
    
    int main_diag[N] = {1, 2, 3, 4, 5}; 
    int lower_diag[N - 1] = {6, 7, 8, 9}; 
    int upper_diag[N - 1] = {11, 12, 13, 14}; 

    printf("1D Array storage (Main, Lower, Upper diagonals):\n");
    printf("Main: "); for(int i=0; i<N; i++) printf("%d ", main_diag[i]); printf("\n");
    printf("Lower: "); for(int i=0; i<N-1; i++) printf("%d ", lower_diag[i]); printf("\n");
    printf("Upper: "); for(int i=0; i<N-1; i++) printf("%d ", upper_diag[i]); printf("\n");
    printf("\nConceptual Matrix:\n");
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            if (i == j) {
                printf("%d ", main_diag[i]);
            } else if (i == j + 1) { 
                printf("%d ", lower_diag[j]);
            } else if (i == j - 1) { 
                printf("%d ", upper_diag[i]);
            } else {
                printf("0 ");
            }
        }
        printf("\n");
    }

    printf("\nAccessing A[2][2]: %d (from main_diag[2])\n", main_diag[2]);
    printf("Accessing A[3][2]: %d (from lower_diag[2])\n", lower_diag[2]); 
    printf("Accessing A[1][2]: %d (from upper_diag[1])\n", upper_diag[1]); 
    printf("Accessing A[0][3]: 0 (off-band)\n");
    printf("-------------------------------------------\n\n");
}


void demonstrateLowerTriangularMatrix() {
    printf("--- (c) Lower Triangular Matrix (N=%d) ---\n", N);
    
    int num_elements = N * (N + 1) / 2;
    int lower_tri_elements[num_elements];
    int val = 1;
    for (int i = 0; i < num_elements; i++) {
        lower_tri_elements[i] = val++;
    }

    printf("1D Array storage: ");
    for(int i = 0; i < num_elements; i++) printf("%d ", lower_tri_elements[i]);
    printf("\n\nConceptual Matrix:\n");
    int k = 0; 
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            if (i >= j) { 
                printf("%d ", lower_tri_elements[k++]);
            } else {
                printf("0 ");
            }
        }
        printf("\n");
    }

    printf("\nAccessing A[3][1]: "); 
    int row_idx = 3;
    int col_idx = 1;
    if (row_idx >= col_idx) {
        
        int index = (row_idx * (row_idx + 1) / 2) + col_idx;
        printf("%d (from 1D array index %d)\n", lower_tri_elements[index], index);
    } else {
        printf("0 (above diagonal)\n");
    }

    printf("Accessing A[1][3]: "); 
    row_idx = 1; col_idx = 3;
    if (row_idx >= col_idx) {
        int index = (row_idx * (row_idx + 1) / 2) + col_idx;
        printf("%d (from 1D array index %d)\n", lower_tri_elements[index], index);
    } else {
        printf("0 (above diagonal)\n");
    }
  
}


void demonstrateUpperTriangularMatrix() {
    printf("--- (d) Upper Triangular Matrix (N=%d) ---\n", N);
   
    int num_elements = N * (N + 1) / 2;
    int upper_tri_elements[num_elements];
    int val = 1;
    for (int i = 0; i < num_elements; i++) {
        upper_tri_elements[i] = val++;
    }

    printf("1D Array storage: ");
    for(int i = 0; i < num_elements; i++) printf("%d ", upper_tri_elements[i]);
    printf("\n\nConceptual Matrix:\n");
    int k = 0;
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            if (i <= j) { 
                printf("%d ", upper_tri_elements[k++]);
            } else {
                printf("0 ");
            }
        }
        printf("\n");
    }

    printf("\nAccessing A[1][3]: ");
    int row_idx = 1;
    int col_idx = 3;
    if (row_idx <= col_idx) {
      
        int index = 0;
        for (int r = 0; r < row_idx; r++) {
            index += (N - r); 
        }
        index += (col_idx - row_idx); 
        printf("%d (from 1D array index %d)\n", upper_tri_elements[index], index);
    } else {
        printf("0 (below diagonal)\n");
    }

    printf("Accessing A[3][1]: "); 
    row_idx = 3; col_idx = 1;
    if (row_idx <= col_idx) {
        int index = 0;
        for (int r = 0; r < row_idx; r++) {
            index += (N - r);
        }
        index += (col_idx - row_idx);
        printf("%d (from 1D array index %d)\n", upper_tri_elements[index], index);
    } else {
        printf("0 (below diagonal)\n");
    }
  
}


void demonstrateSymmetricMatrix() {
    printf("--- (e) Symmetric Matrix (N=%d) ---\n", N);
    
    int num_elements = N * (N + 1) / 2;
   
    int sym_elements_lower_tri[num_elements] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15}; 

    printf("1D Array storage (Lower Triangle + Diagonal): ");
    for(int i = 0; i < num_elements; i++) printf("%d ", sym_elements_lower_tri[i]);
    printf("\n\nConceptual Matrix:\n");
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            if (i >= j) { 
                printf("%d ", sym_elements_lower_tri[(i * (i + 1) / 2) + j]);
            } else { 
                printf("%d ", sym_elements_lower_tri[(j * (j + 1) / 2) + i]);
            }
        }
        printf("\n");
    }

    printf("\nAccessing A[3][1]: "); 
    int row_idx = 3;
    int col_idx = 1;
    if (row_idx >= col_idx) { 
        int index = (row_idx * (row_idx + 1) / 2) + col_idx;
        printf("%d (from 1D array index %d)\n", sym_elements_lower_tri[index], index);
    } else { 
        int index = (col_idx * (col_idx + 1) / 2) + row_idx;
        printf("%d (mapped from A[%d][%d] at 1D array index %d)\n", sym_elements_lower_tri[index], col_idx, row_idx, index);
    }

    printf("Accessing A[1][3]: ");
    row_idx = 1;
    col_idx = 3;
    if (row_idx >= col_idx) { 
        int index = (row_idx * (row_idx + 1) / 2) + col_idx;
        printf("%d (from 1D array index %d)\n", sym_elements_lower_tri[index], index);
    } else { 
        int index = (col_idx * (col_idx + 1) / 2) + row_idx;
        printf("%d (mapped from A[%d][%d] at 1D array index %d)\n", sym_elements_lower_tri[index], col_idx, row_idx, index);
    }
    
}


int main() {
    demonstrateDiagonalMatrix();
    demonstrateTridiagonalMatrix();
    demonstrateLowerTriangularMatrix();
    demonstrateUpperTriangularMatrix();
    demonstrateSymmetricMatrix();
    return 0;
}

//q6

#include <stdio.h>


#define MAX_TRIPLETS 100

#define MAX_DIMENSION 100


typedef struct {
    int row;
    int col;
    int value;
} Triplet;


void printSparseMatrix(Triplet sparseMatrix[]) {
    int num_elements = sparseMatrix[0].value;
    printf("Sparse Matrix (Triplet Form):\n");
    printf("Rows: %d, Cols: %d, Non-zero elements: %d\n",
           sparseMatrix[0].row, sparseMatrix[0].col, sparseMatrix[0].value);
    printf("Row\tCol\tValue\n");
    for (int i = 1; i <= num_elements; i++) {
        printf("%d\t%d\t%d\n", sparseMatrix[i].row, sparseMatrix[i].col, sparseMatrix[i].value);
    }
}


void transposeSparseMatrix(Triplet original[], Triplet transposed[]) {
    int R = original[0].row;
    int C = original[0].col;
    int num_elements = original[0].value;

    transposed[0].row = C; 
    transposed[0].col = R; 
    transposed[0].value = num_elements;

    if (num_elements == 0) return;

 
    int colCount[MAX_DIMENSION]; 
    int colIndex[MAX_DIMENSION]; 


    for (int i = 0; i < C; i++) {
        colCount[i] = 0;
        colIndex[i] = 0;
    }

    
    for (int i = 1; i <= num_elements; i++) {
        colCount[original[i].col]++;
    }

    
    colIndex[0] = 1; 
    for (int i = 1; i < C; i++) {
        colIndex[i] = colIndex[i - 1] + colCount[i - 1];
    }

  
    for (int i = 1; i <= num_elements; i++) {
        int original_col = original[i].col;
        int new_position = colIndex[original_col];

        transposed[new_position].row = original[i].col;   
        transposed[new_position].col = original[i].row;   
        transposed[new_position].value = original[i].value;

        colIndex[original_col]++; 
    }
}


void addSparseMatrices(Triplet mat1[], Triplet mat2[], Triplet result[]) {
    if (mat1[0].row != mat2[0].row || mat1[0].col != mat2[0].col) {
        printf("Error: Matrices must have same dimensions for addition.\n");
        result[0].value = 0; 
        return;
    }

    result[0].row = mat1[0].row;
    result[0].col = mat1[0].col;

    int i = 1, j = 1, k = 1; 
    while (i <= mat1[0].value && j <= mat2[0].value) {
        
        if (mat1[i].row < mat2[j].row || (mat1[i].row == mat2[j].row && mat1[i].col < mat2[j].col)) {
            
            if (k >= MAX_TRIPLETS) {
                printf("Resulting sparse matrix exceeds MAX_TRIPLETS capacity during addition.\n");
                break;
            }
            result[k++] = mat1[i++];
        } else if (mat1[i].row > mat2[j].row || (mat1[i].row == mat2[j].row && mat1[i].col > mat2[j].col)) {
            
            if (k >= MAX_TRIPLETS) {
                printf("Resulting sparse matrix exceeds MAX_TRIPLETS capacity during addition.\n");
                break;
            }
            result[k++] = mat2[j++];
        } else {
            
            result[k].row = mat1[i].row;
            result[k].col = mat1[i].col;
            result[k].value = mat1[i].value + mat2[j].value;
            
            if (result[k].value != 0) {
                if (k >= MAX_TRIPLETS) {
                    printf("Resulting sparse matrix exceeds MAX_TRIPLETS capacity during addition.\n");
                    break;
                }
                k++;
            }
            i++;
            j++;
        }
    }

    
    while (i <= mat1[0].value) {
        if (k >= MAX_TRIPLETS) {
            printf("Resulting sparse matrix exceeds MAX_TRIPLETS capacity during addition.\n");
            break;
        }
        result[k++] = mat1[i++];
    }


    while (j <= mat2[0].value) {
        if (k >= MAX_TRIPLETS) {
            printf("Resulting sparse matrix exceeds MAX_TRIPLETS capacity during addition.\n");
            break;
        }
        result[k++] = mat2[j++];
    }

    result[0].value = k - 1; 
}


void multiplySparseMatrices(Triplet mat1[], Triplet mat2[], Triplet result[]) {
    if (mat1[0].col != mat2[0].row) {
        printf("Error: Matrix multiplication not possible. Columns of Mat1 != Rows of Mat2.\n");
        result[0].value = 0;
        return;
    }

    result[0].row = mat1[0].row;
    result[0].col = mat2[0].col;
    result[0].value = 0;

    int R1 = mat1[0].row; 
    int C1 = mat1[0].col;
    int C2 = mat2[0].col; 
    
    
    int temp_dense_result[MAX_DIMENSION][MAX_DIMENSION];

    for (int i = 0; i < R1; i++) {
        for (int j = 0; j < C2; j++) {
            temp_dense_result[i][j] = 0;
        }
    }


    for (int i = 1; i <= mat1[0].value; i++) {
        int r1 = mat1[i].row;
        int c1 = mat1[i].col;
        int val1 = mat1[i].value;

        for (int j = 1; j <= mat2[0].value; j++) {
            int r2 = mat2[j].row;
            int c2 = mat2[j].col;
            int val2 = mat2[j].value;

           
            if (c1 == r2) {
              
                if (r1 < R1 && c2 < C2) {
                    temp_dense_result[r1][c2] += val1 * val2;
                } else {
                    printf("Warning: Array index out of bounds during multiplication for dense result (likely MAX_DIMENSION too small).\n");
                }
            }
        }
    }

   
    int k = 1;
    for (int r = 0; r < R1; r++) {
        for (int c = 0; c < C2; c++) {
            if (temp_dense_result[r][c] != 0) {
                if (k >= MAX_TRIPLETS) {
                    printf("Resulting sparse matrix exceeds MAX_TRIPLETS capacity after multiplication.\n");
                    break;
                }
                result[k].row = r;
                result[k].col = c;
                result[k].value = temp_dense_result[r][c];
                k++;
            }
        }
    }
    result[0].value = k - 1; 
}

int main() {
    // --- Example Sparse Matrix 1 ---
    // A 4x5 matrix with 3 non-zero elements
    // 0 0 3 0 0
    // 0 0 0 0 0
    // 0 1 0 0 0
    // 0 0 0 2 0
    Triplet mat1[MAX_TRIPLETS] = {
        {4, 5, 3}, // Header: Rows, Cols, Non-zero elements
        {0, 2, 3}, // Element at (row 0, col 2) is 3
        {2, 1, 1}, // Element at (row 2, col 1) is 1
        {3, 3, 2}  // Element at (row 3, col 3) is 2
    };
    printf("--- Sparse Matrix 1 ---\n");
    printSparseMatrix(mat1);

    // --- (a) Transpose ---
    Triplet transposed_mat1[MAX_TRIPLETS];
    transposeSparseMatrix(mat1, transposed_mat1);
    printf("\n--- Transpose of Sparse Matrix 1 ---\n");
    printSparseMatrix(transposed_mat1);

    // --- Example Sparse Matrix 2 for Addition ---
    // A 4x5 matrix with 2 non-zero elements (same dimensions as mat1)
    // 0 0 0 0 0
    // 0 5 0 0 0
    // 0 0 0 0 0
    // 0 0 0 0 6
    Triplet mat2[MAX_TRIPLETS] = {
        {4, 5, 2}, // Header
        {1, 1, 5}, // Element at (row 1, col 1) is 5
        {3, 4, 6}  // Element at (row 3, col 4) is 6
    };
    printf("\n--- Sparse Matrix 2 (for Addition) ---\n");
    printSparseMatrix(mat2);

    // --- (b) Addition ---
    Triplet sum_result[MAX_TRIPLETS];
    addSparseMatrices(mat1, mat2, sum_result);
    printf("\n--- Sum of Sparse Matrix 1 and Sparse Matrix 2 ---\n");
    printSparseMatrix(sum_result);

    // --- Example Sparse Matrices for Multiplication ---
    // MatA: 2x3
    // 1 0 2
    // 0 3 0
    Triplet matA[MAX_TRIPLETS] = {
        {2, 3, 3}, // Header
        {0, 0, 1},
        {0, 2, 2},
        {1, 1, 3}
    };
    printf("\n--- Sparse Matrix A (for Multiplication) ---\n");
    printSparseMatrix(matA);

    // MatB: 3x2
    // 4 0
    // 0 5
    // 6 0
    Triplet matB[MAX_TRIPLETS] = {
        {3, 2, 3}, // Header
        {0, 0, 4},
        {1, 1, 5},
        {2, 0, 6}
    };
    printf("\n--- Sparse Matrix B (for Multiplication) ---\n");
    printSparseMatrix(matB);

    // --- (c) Multiplication ---
    Triplet prod_result[MAX_TRIPLETS];
    multiplySparseMatrices(matA, matB, prod_result);
    printf("\n--- Product of Sparse Matrix A and Sparse Matrix B ---\n");
    printSparseMatrix(prod_result);

    return 0;
}

//q7

#include <stdio.h>


long long countInversions(int arr[], int size) {
    long long inversions = 0; 

   
    for (int i = 0; i < size - 1; i++) {
      
        for (int j = i + 1; j < size; j++) {
            
            if (arr[i] > arr[j]) {io
                inversions++;
            }
        }
    }
    return inversions;
}

int main() {
  
    int arr1[] = {1, 2, 3, 4, 5};
    int n1 = sizeof(arr1) / sizeof(arr1[0]);
    printf("Array 1: ");
    for (int i = 0; i < n1; i++) {
        printf("%d ", arr1[i]);
    }
    printf("\nNumber of inversions in Array 1: %lld\n\n", countInversions(arr1, n1));


    int arr2[] = {5, 4, 3, 2, 1};
    int n2 = sizeof(arr2) / sizeof(arr2[0]);
    printf("Array 2: ");
    for (int i = 0; i < n2; i++) {
        printf("%d ", arr2[i]);
    }
    printf("\nNumber of inversions in Array 2: %lld\n\n", countInversions(arr2, n2));

    
    int arr3[] = {8, 4, 2, 1};
    int n3 = sizeof(arr3) / sizeof(arr3[0]);
    printf("Array 3: ");
    for (int i = 0; i < n3; i++) {
        printf("%d ", arr3[i]);
    }
    printf("\nNumber of inversions in Array 3: %lld\n\n", countInversions(arr3, n3));

 
    int arr4[] = {10, 20, 5, 15};
    int n4 = sizeof(arr4) / sizeof(arr4[0]);
    printf("Array 4: ");
    for (int i = 0; i < n4; i++) {
        printf("%d ", arr4[i]);
    }
    printf("\nNumber of inversions in Array 4: %lld\n\n", countInversions(arr4, n4));

    return 0;
}


//q8

#include <stdio.h>

int countDistinctElements(int arr[], int size) {
    if (size == 0) {
        return 0;
    }

    int distinctCount = 0;

    for (int i = 0; i < size; i++) {
        int isDistinct = 1;

        for (int j = 0; j < i; j++) {
            if (arr[i] == arr[j]) {
                isDistinct = 0;
                break;
            }
        }

        if (isDistinct) {
            distinctCount++;
        }
    }
    return distinctCount;
}

int main() {
    int arr1[] = {10, 20, 20, 10, 30, 10, 50};
    int n1 = sizeof(arr1) / sizeof(arr1[0]);
    printf("Array 1: ");
    for(int i = 0; i < n1; i++) printf("%d ", arr1[i]);
    printf("\nTotal distinct elements in Array 1: %d\n\n", countDistinctElements(arr1, n1));

    int arr2[] = {1, 2, 3, 4, 5};
    int n2 = sizeof(arr2) / sizeof(arr2[0]);
    printf("Array 2: ");
    for(int i = 0; i < n2; i++) printf("%d ", arr2[i]);
    printf("\nTotal distinct elements in Array 2: %d\n\n", countDistinctElements(arr2, n2));

    int arr3[] = {7, 7, 7, 7, 7};
    int n3 = sizeof(arr3) / sizeof(arr3[0]);
    printf("Array 3: ");
    for(int i = 0; i < n3; i++) printf("%d ", arr3[i]);
    printf("\nTotal distinct elements in Array 3: %d\n\n", countDistinctElements(arr3, n3));

    int arr4[] = {};
    int n4 = 0;
    printf("Array 4: (empty)\n");
    printf("Total distinct elements in Array 4: %d\n\n", countDistinctElements(arr4, n4));

    int arr5[] = { -1, 0, 5, -1, 0, 10, 5};
    int n5 = sizeof(arr5) / sizeof(arr5[0]);
    printf("Array 5: ");
    for(int i = 0; i < n5; i++) printf("%d ", arr5[i]);
    printf("\nTotal distinct elements in Array 5: %d\n\n", countDistinctElements(arr5, n5));

    return 0;
}



